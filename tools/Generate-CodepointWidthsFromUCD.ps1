# Copyright (c) Microsoft Corporation.
# Licensed under the MIT license.

[CmdletBinding()]
Param(
	[Parameter(Position=0, ValueFromPipeline=$true, ParameterSetName="Parsed")]
	[System.Xml.XmlDocument]$InputObject,

	[Parameter(Position=0, ValueFromPipelineByPropertyName=$true, ParameterSetName="Unparsed")]
	[string]$Path = "ucd.nounihan.flat.xml",

	[switch]$Pack, # Pack tightly based on width
	[switch]$Full = $False # Include Narrow codepoints
)

Enum CodepointWidth {
	Narrow;
	Wide;
	Ambiguous;
	Invalid;
}

If ($InputObject -eq $Null) {
	$InputObject = [xml](Get-Content $Path)
}

$UCDRepertoire = $InputObject.ucd.repertoire.ChildNodes | Sort {
	# Sort by either cp or first-cp (for ranges)
	if ($_.cp -ne $null) {
		[int]("0x"+$_.cp)
	} elseif ($_."first-cp" -ne $null) {
		[int]("0x"+$_."first-cp")
	}
}

If (-Not $Full) {
	$UCDRepertoire = $UCDRepertoire | ? {
		# Select everything Wide/Ambig/Full OR Emoji w/ Emoji Presentation
		($_.ea -notin "N", "Na", "H") -or ($_.Emoji -eq "Y" -and $_.EPres -eq "Y")
	}
}

function Get-EntryWidth($entry) {
	If ($entry.Emoji -eq "Y" -and $entry.EPres -eq "Y") {
		[CodepointWidth]::Wide
		Return
	}

	Switch($entry.ea) {
		"N"  { [CodepointWidth]::Narrow; Return }
		"Na" { [CodepointWidth]::Narrow; Return }
		"H"  { [CodepointWidth]::Narrow; Return }
		"W"  { [CodepointWidth]::Wide; Return }
		"F"  { [CodepointWidth]::Wide; Return }
		"A"  { [CodepointWidth]::Ambiguous; Return }
	}
	[CodepointWidth]::Invalid
}

function Get-EntryFlags($entry) {
	If ($Pack) {
		# If we're "pack"ing entries, only the width matters for telling them apart
		Get-EntryWidth $entry
		Return
	}

	$normalizedEAWidth = $entry.ea
	$normalizedEAWidth = $normalizedEAWidth -eq "F" ? "W" : $normalizedEAWidth;
	$EPres = $entry.EPres
	If ($normalizedEAWidth -eq "W" -and $entry.Emoji -eq "Y") {
		# Pretend wide glyphs that are emoji are already using EPres
		$EPres = "Y"
	}
	"{0}{1}{2}" -f $normalizedEAWidth, $EPres, $EPres
}

function New-Range($s, $e, $entry) {
	$Width = Get-EntryWidth $entry
	$Comment = $null

	If ($entry.Emoji -eq "Y" -and $entry.EPres -eq "Y") {
		$Comment = "Emoji=Y EPres=Y"
	}

	$Flags = Get-EntryFlags $entry

	[PSCustomObject]@{
		Start=$s;
		End=$e;
		Width=$Width;
		Comment=$Comment;
		Flags=$Flags;
	}
}

function Discontinuous($range, $s, $entry) {
	If (($s - $range.End) -gt 1) {
		# More than one codepoint between end of last and start of this
		$True
		Return
	} Else {
		$newFlags = Get-EntryFlags $entry
		If ($newFlags -ne $range.Flags) {
			# Continuous, but the flags don't match
			$True
			Return
		}
	}
	$False
	Return
}

$ranges = @()
$last = $null

function Vend()
{
	if ($Script:last -ne $null) {
		$Script:ranges += $Script:last
	}
	$Script:last=$null
}

function Accumulate($s, $e, $entry) {
	if ($Script:last -eq $null) {
		$Script:last = New-Range $s $e $entry
		# Made a new range, done
		Return
	}

	# Updating an existing range
	If (Discontinuous $Script:last $s $entry) {
		# start point is discontinuous with last end
		Vend
		# Re-run accumulate so that we register the new entry
		Accumulate $s $e $entry
		Return
	}

	# Expand last range to encompass this entry
	$Script:last.End = $e
}

ForEach($v in $UCDRepertoire) {
	$s = $e = 0
	if ($v.cp -ne $null) {
		# Individual Codepoint
		$s = $e = [int]("0x"+$v.cp)
	} elseif ($v."first-cp" -ne $null) {
		# Range of Codepoints
		$s = [int]("0x"+$v."first-cp")
		$e = [int]("0x"+$v."last-cp")
	}
	Accumulate $s $e $v
}
Vend

# Emit Code
$c = 0
ForEach($_ in $ranges) { $c += ($_.End - $_.Start) + 1 }
"    // Generated by Generate-CodepointWidthsFromUCD -Pack:$Pack -Full:$Full"
"    // on $(Get-Date -AsUTC) (UTC) from $($InputObject.ucd.description)."
"    // $($c) ($("0x{0:X}" -f $c)) codepoints covered."
"    static constexpr std::array<UnicodeRange, $($ranges.Length)> s_wideAndAmbiguousTable{"
ForEach($_ in $ranges) {
	$sstr = ""
	if (-Not $Pack -and $_.Comment -ne $null) {
		# We only vend comments when we aren't packing tightly
		$sstr = " // "+$_.Comment
	}
	"        UnicodeRange{{ 0x{0:x}, 0x{1:x}, CodepointWidth::{2} }},{3}" -f $_.Start, $_.End, $_.Width, $sstr
}
"    };"
