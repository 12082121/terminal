# Copyright (c) Microsoft Corporation.
# Licensed under the MIT license.

[Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidUsingPositionalParameters', '')]
[Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseProcessBlockForPipelineCommand', '')]
[CmdletBinding()]
Param(
    [Parameter(Position=0, ValueFromPipeline=$true, ParameterSetName="Parsed")]
    [System.Xml.XmlDocument]$InputObject,

    [Parameter(Position=0, ValueFromPipelineByPropertyName=$true, ParameterSetName="Unparsed")]
    [string]$Path = "ucd.nounihan.flat.xml",

    [switch]$Pack, # Pack tightly based on width
    [switch]$Full = $False # Include Narrow codepoints
)

Enum CodepointWidth {
    Narrow;
    Wide;
    Ambiguous;
    Invalid;
}

If ($null -eq $InputObject) {
    $InputObject = [xml](Get-Content $Path)
}

$UCDRepertoire = $InputObject.ucd.repertoire.ChildNodes | Sort-Object {
    # Sort by either cp or first-cp (for ranges)
    if ($null -Ne $_.cp) {
        [int]("0x"+$_.cp)
    } ElseIf ($null -Ne $_."first-cp") {
        [int]("0x"+$_."first-cp")
    }
}

If (-Not $Full) {
    $UCDRepertoire = $UCDRepertoire | Where-Object {
        # Select everything Wide/Ambiguous/Full OR Emoji w/ Emoji Presentation
        ($_.ea -NotIn "N", "Na", "H") -Or ($_.Emoji -Eq "Y" -And $_.EPres -Eq "Y")
    }
}

Function Get-EntryWidth($entry) {
    If ($entry.Emoji -Eq "Y" -And $entry.EPres -Eq "Y") {
        [CodepointWidth]::Wide
        Return
    }

    Switch($entry.ea) {
        "N"  { [CodepointWidth]::Narrow; Return }
        "Na" { [CodepointWidth]::Narrow; Return }
        "H"  { [CodepointWidth]::Narrow; Return }
        "W"  { [CodepointWidth]::Wide; Return }
        "F"  { [CodepointWidth]::Wide; Return }
        "A"  { [CodepointWidth]::Ambiguous; Return }
    }
    [CodepointWidth]::Invalid
}

Function Get-EntryFlags($entry) {
    If ($Pack) {
        # If we're "pack"ing entries, only the width matters for telling them apart
        Get-EntryWidth $entry
        Return
    }

    $normalizedEAWidth = $entry.ea
    $normalizedEAWidth = $normalizedEAWidth -Eq "F" ? "W" : $normalizedEAWidth;
    $EPres = $entry.EPres
    If ($normalizedEAWidth -Eq "W" -And $entry.Emoji -Eq "Y") {
        # Pretend wide glyphs that are emoji are already using EPres
        $EPres = "Y"
    }
    "{0}{1}{2}" -f $normalizedEAWidth, $EPres, $EPres
}

Function Initialize-Range($s, $e, $entry) {
    $Width = Get-EntryWidth $entry
    $Comment = $null

    If ($entry.Emoji -Eq "Y" -And $entry.EPres -Eq "Y") {
        $Comment = "Emoji=Y EPres=Y"
    }

    $Flags = Get-EntryFlags $entry

    [PSCustomObject]@{
        Start=$s;
        End=$e;
        Width=$Width;
        Comment=$Comment;
        Flags=$Flags;
    }
}

Function Discontinuous($range, $s, $entry) {
    If (($s - $range.End) -gt 1) {
        # More than one codepoint between end of last and start of this
        $True
        Return
    } Else {
        $newFlags = Get-EntryFlags $entry
        If ($newFlags -Ne $range.Flags) {
            # Continuous, but the flags don't match
            $True
            Return
        }
    }
    $False
    Return
}

$ranges = @()
$last = $null

Function Vend() {
    if ($null -Ne $Script:last) {
        $Script:ranges += $Script:last
    }
    $Script:last=$null
}

Function Accumulate($s, $e, $entry) {
    if ($null -Eq $Script:last) {
        $Script:last = Initialize-Range $s $e $entry
        # Made a new range, done
        Return
    }

    # Updating an existing range
    If (Discontinuous $Script:last $s $entry) {
        # start point is discontinuous with last end
        Vend
        # Re-run accumulate so that we register the new entry
        Accumulate $s $e $entry
        Return
    }

    # Expand last range to encompass this entry
    $Script:last.End = $e
}

ForEach($v in $UCDRepertoire) {
    $s = $e = 0
    if ($null -Ne $v.cp) {
        # Individual Codepoint
        $s = $e = [int]("0x"+$v.cp)
    } ElseIf ($null -Ne $v."first-cp") {
        # Range of Codepoints
        $s = [int]("0x"+$v."first-cp")
        $e = [int]("0x"+$v."last-cp")
    }
    Accumulate $s $e $v
}
Vend

# Emit Code
$c = 0
ForEach($_ in $ranges) { $c += ($_.End - $_.Start) + 1 }
"    // Generated by Generate-CodepointWidthsFromUCD -Pack:{0} -Full:{1}" -f $Pack, $Full
"    // on {0} (UTC) from {1}." -f (Get-Date -AsUTC), $InputObject.ucd.description
"    // {0} (0x{0:X}) codepoints covered." -f $c
"    static constexpr std::array<UnicodeRange, {0}> s_wideAndAmbiguousTable{{" -f $ranges.Length
ForEach($_ in $ranges) {
	$comment = ""
    if (-Not $Pack -And $null -Ne $_.Comment) {
        # We only vend comments when we aren't packing tightly
        $comment = " // {0}" -f $_.Comment
    }
    "        UnicodeRange{{ 0x{0:x}, 0x{1:x}, CodepointWidth::{2} }},{3}" -f $_.Start, $_.End, $_.Width, $sstr
}
"    };"
